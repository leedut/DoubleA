//socket通信部分
var io = require('socket.io').listen(9000);

io.sockets.on('connection', function (socket) {
    console.log('Socket服务端启动,端口9000');
    socket.on('message', function(msg) {
        doMsg(socket,msg);
    });
});

/*
*   Socket消息处理函数
*/
function doMsg(socket,msg){
    var addr = socket.handshake.address;
    msg = eval('('+msg+')');
    var type = msg.type;
    var content = msg.content;
    var response = "";
    var broad = "";
    switch(type){
        case 1:{
            //分配座位  初始化当前房间信息  广播刚进入人的信息
            response = startSeat(content);
            broad = {type:101,content:[response.content[0],content,false]};
            socket.send(response);
            socket.broadcast.send(broad);
        };break;
        case 2:{
            //用户准备 广播刚准备的信息 
            //检查是否所有人都已准备，若是自动开始游戏
            player[content-1].ready = true;
            if( checkReady() ){
                //所有玩家都准备：开始游戏  广播发牌 随机选定最先出牌的人
                var _poc =randomPock();
                _poc.push(random(1,4));
                broad = {type:103,content:_poc};
                socket.send(broad);
                socket.broadcast.send(broad);
            }
            else{
                //广播某玩家的准备信息
                broad = {type:102,content:msg.content};
                socket.broadcast.send(broad);
            }
        };break;
        case 3:{
            //亮单A 广播
            if(startFlag == false ){
                var i = random(1,4);
                broad = {type:104,content:msg.content};
                socket.broadcast.send(broad);
                //保存分组信息
                pushA(msg.content);
                //广播出牌信息 i 为当前应出牌
                broad = {type:106,content:[i,lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
                startFlag = true;
                socket.send(broad);
                socket.broadcast.send(broad);
                console.log("第一个出牌的人："+i+"广播信息"+broad.content);
            }
            else{
                //第二个人亮A时无需指定谁先出牌了
                pushA(msg.content);
                broad = {type:104,content:msg.content};
                socket.broadcast.send(broad);
            }
        };break;
        case 4:{
            //亮双A 广播
            pushA(msg.content);
            var i = random(1,4);
            broad = {type:105,content:msg.content};
            socket.broadcast.send(broad);
            broad = {type:106,content:[i,lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
            socket.broadcast.send(broad);
            socket.send(broad);
            startFlag = true;
            console.log("第一个出牌的人："+i);
        };break;
        case 5:{
            var this_id = content[0];
            //对ID：content[0]的人的出牌信息进行更新
            player[this_id-1].rest = player[this_id-1].rest -content[1].length;
            lastPoc[this_id-1] = content[1];
            //某人出牌结束
            if( player[this_id-1].rest == 0 ){
                //广播某人的出牌结束信息 如果不在list里，则加入finishlist
                var flag = true;
                for(var i = 0;i<finishList.length;i++){
                    if(finishList[i]==this_id){
                        flag = false;
                        break;
                    }
                }
                if(flag){
                    finishList.push(this_id);
                    //广播出牌信息 最后一张牌需要提前广播，客户端接收到完牌信息后就不再更新显示
                    var nextID = 0;
                    switch(this_id){
                        case 1 :nextID=2;break;
                        case 2 :nextID=3;break;
                        case 3 :nextID=4;break;
                        case 4 :nextID=1;break;
                    }
                    broad = {type:106,content:[nextID,lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
                    socket.broadcast.send(broad);
                    //广播出完牌信息
                    broad = {type:107,content:this_id};
                    socket.broadcast.send(broad);
                    socket.send(broad);
                    return true;
                }
            }
            //判断是否比赛结束
            if( checkFinished().flag ){
                //所有获胜者的id  content格式 [[id1,name1],[id2,name2]]
                winner = checkFinished().winner;
                var temp = [];
                for(var i=0;i<winner.length;i++){
                    temp.push( [winner[i],player[winner[i]-1].name] );
                }
                broad = {type:108,content:temp};
                console.log("本场结束，winner:"+temp);
                socket.broadcast.send(broad);
                socket.send(broad);
                //数据重置
                for(var i=0;i<4;i++){
                    player[i].ready = false;
                    player[i].rest = 13;
                }
                startFlag = false ;
                blackA = [];
                lastPoc=[[],[],[],[]];
                finishList =[];
                
                return true;
            }
            if( lastPoc[0].length==0 && lastPoc[1].length==0 && lastPoc[2].length==0 && lastPoc[3].length==0 ){
                //当四个人的出牌纪录均为空时,却还有人没出完牌 指定最近一个完成出牌的人的队友出牌
                var _pos = finishList.length;
                var recent_id = finishList[_pos-1];
                var partner = getPartner(recent_id);
                for(var i=0;i<partner.length;i++){
                    //把牌权转让给非自己的未完成选手
                    if(partner[i]!=recent_id){
                        if( !hasOneFinished(partner[i]) ){
                            console.log(partner+"是"+recent_id+"的队友");
                            console.log(partner[i]+"接过牌权\n");
                            broad = {type:106,content:[partner[i],lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
                            socket.send(broad);
                            socket.broadcast.send(broad);
                            return ;
                        }
                    }
                }
            }
            //广播出牌信息
            var nextID = 0;
            switch(this_id){
                case 1 :nextID=2;break;
                case 2 :nextID=3;break;
                case 3 :nextID=4;break;
                case 4 :nextID=1;break;
            }
            broad = {type:106,content:[nextID,lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
            socket.broadcast.send(broad);
            socket.send(broad);
            console.log(nextID+"该出牌，\n"+lastPoc[0]+"\n"+lastPoc[1]+"\n"+lastPoc[2]+"\n"+lastPoc[3]);
        };break;
        case 6:{
            //不亮双A 需保存分组信息，并发牌
            if( content[1] == 2 ){
                pushA(content[0]);
                //广播第一次出牌信息 i 为当前应出牌
                broad = {type:106,content:[msg.content[0],lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
                startFlag = true;
                socket.send(broad);
                socket.broadcast.send(broad);
                console.log("第一个出牌的人："+i+"广播信息"+broad.content);
            }
            else{
                if(blackA.length==2){
                    var i = random(1,4);
                    broad = {type:106,content:[i,lastPoc[0],lastPoc[1],lastPoc[2],lastPoc[3]]};
                    startFlag = true;
                    socket.send(broad);
                    socket.broadcast.send(broad);
                    console.log("第一个出牌的人："+i+"广播信息"+broad.content);
                }
                pushA(content[0]);
            }
            pushA(msg.content);
        };break;
        default:break;
        case 7:{
            //游戏语音
            broad = {type:200,content:msg.content};
            socket.broadcast.send(broad);
            socket.send(broad);
        };break;
        case 8:{
            //游戏聊天文字
            var _name =player[content[0]-1].name;
            var _word = content[1];
            broad = {type:201,content:[_name,_word]};
            socket.broadcast.send(broad);
            socket.send(broad);
        };break;
    }
    console.log("from"+addr+": 消息类别"+msg.type+" 消息原文"+msg.content);
}
//游戏设定部分
var player =[ 
    {id:1,in:false,name:"",ready:false,rest:13},
    {id:2,in:false,name:"",ready:false,rest:13},
    {id:3,in:false,name:"",ready:false,rest:13},
    {id:4,in:false,name:"",ready:false,rest:13}];
//是否指定谁先出牌了
var startFlag = false ;
var blackA = [];
//用于保存上一组人的牌
var lastPoc=[[],[],[],[]];
//用于保存先后出光牌的 id 
var finishList =[];

//检查是否所有玩家均已准备
function checkReady(){
    for(var i =0;i<4;i++){
        if(player[i].ready==false){
            return false;
        }
    }
    return true;
}
//发牌函数
function random(min,max){
    return Math.floor(min+Math.random()*(max-min));
}
function randomPock(){
    var pock_list = [];
    for(var i = 0 ;i<52;i++){
        pock_list.push(1);
    }
    var pos = 0;
    var mypock = [];
    //前两组牌
    for( var j = 0; j < 2 ; j++){
        mypock[j] = [];
        for( i =0;i<13;i++){
            while(true){
                pos = random(1,52)
                if( pock_list[pos] ==1 ){
                    point = pos%13;
                    if(point==1){
                        point = 14;
                    }
                    else if(point == 2 ){
                        point = 15;
                    }
                    else if(point == 0 ){
                        point = 13;
                    }
                    color = parseInt(pos/13)+1;
                    mypock[j].push([point,color]);
                    pock_list[pos] = 0;
                    break;
                }
            }
        }
    }
    //第三组牌
    var new_pock_list = [];
    for( i =0 ;i<52;i++){
        if(pock_list[i]==1){
            new_pock_list.push(i);
        }
    }
    mypock[2] = [];
    for( i =0;i<13;i++){
        while(true){
            _r = random(1,26);
            pos = new_pock_list[_r];
            if( pock_list[pos] == 1 ){
                point = pos%13;
                if(point==1){
                    point = 14;
                }
                else if(point == 2 ){
                    point = 15;
                }
                else if(point == 0 ){
                    point = 13;
                }
                color = parseInt(pos/13)+1;
                mypock[2].push([point,color]);
                pock_list[pos] = 0;
                break;
            }
        }
    }
    //第四组牌
    mypock[3] = [];
    for( i =0;i<52;i++){
        if( pock_list[i] == 1 ){
            point = i%13;
            if(point==1){
                point = 14;
            }
            else if(point == 2 ){
                point = 15;
            }
            else if(point == 0 ){
                point = 13;
            }
            color = parseInt(i/13)+1;
            mypock[3].push([point,color]);
        }
    }
    //牌的排序
    for(i = 0;i<4;i++){
        mypock[i].sort(function(a,b){
            if(a[0]<b[0]){
                return 1;
            }
            else if(a[0]==b[0]){
                if(a[1]>b[1]){
                    return 1;
                }
            }
            return -1;
        });
    }
    return mypock;
}




//Type 1          
//分配座位  初始化当前房间信息 id:为其分配的ID  arr：其他人的信息
function startSeat(content){
    var id = 0;
    var arr = [];
    for(var i=0;i<4;i++){
        if( player[i].in == false ){
            player[i].in=true;
            player[i].name=content;
            id = player[i].id;
            break;
        }
    }
    arr.push(id);
    //其他用户信息拼装
    for(var i=0;i<4;i++){
        if( player[i].in == true && player[i].id != id ){
            var item = [];
            item.push(player[i].id);
            item.push(player[i].name);
            item.push(player[i].ready);
            arr.push(item);
        }
    }
    return {type:1,content:arr};
}


//pushA  将有黑A的人的信息压入blackA
function pushA(id){
    var inFlag = false;
    for(var i =0;i<blackA.length;i++){
        if(blackA[i]==id){
            inFlag = true;
        }
    }
    if( !inFlag ){
        blackA.push(id);
    }
    console.log(id+"调用pushA函数,当前blackA为"+blackA);    
}
//getPartner 获取某人同伙信息 
function getPartner(id){
    var flagBlackA = false;
    for(var i =0;i<blackA.length;i++){
        if(blackA[i]==id){
            flagBlackA = true;
        }
    }
    if( flagBlackA ){
        //可能为 双A自己 或者 两个单A 
        return blackA;
    }
    else{
        //可能为2个红A 或 3个红A
        return minus(blackA,[1,2,3,4]);
    }
}
//checkFinished() 判断当前牌局是否结束
function minus(arr_1,arr_2){
    //输入minus([2,3],[1,2,3,4]) 返回[1,4]
    var temp = [];
    for(var i =0;i<arr_2.length;i++){
        var flag = true;
        for(var j=0;j<arr_1.length;j++){
            if(arr_2[i]==arr_1[j]){
                flag = false;
                break;
            }
        }
        if(flag){
            temp.push(arr_2[i]);
        }
    }
    return temp;
}
function checkFinished(){
    console.log("已完成名单："+finishList);
    var arr = [];
    var finishNum = finishList.length;
    if( blackA.length==1 ){
        //如果是双A自己
        if(finishNum==1){
            if(finishList[0] == blackA[0]){
                //双黑A自己完成 则双A赢
                arr.push(blackA[0]);
                return {flag:true,winner:arr};
            }
        }
        else if(finishNum==2){
            if(finishList[1]==blackA[0]){
                //如果第二个完成的是双黑A 则平
                return {flag:true,winner:[1,2,3,4]};
            }
            else{
                //否则双黑A输
                return {flag:true,winner:minus(blackA,[1,2,3,4])};
            }
        }
        else{
            //否则双黑A输
            return {flag:true,winner:minus(blackA,[1,2,3,4])};
        }
    }
    else{
        //如果2人一伙
        if(finishNum==2){
            //双A为1,2  finishList为2,3  则 minus返回 [3] 未完成
            //双A为1,2  finishList为1,2  则 minus返回 []  已完成
            //双A为1,2  finishList为3,4  则 minus返回 [3,4] 已完成
            if( minus(blackA,finishList).length == 0 || minus(blackA,finishList).length == 2 ){
                return {flag:true,winner:finishList};
            }
        }
        else if(finishNum==3){
            //双A为1,2  finishList为1,3,2  已完成 双A胜  minus =1
            //双A为1,2  finishList为3,1,2  已完成 平     minus =1
            //双A为1,2  finishList为3,1,4  已完成 非双A胜  minus=2
            //双A为1,2  finishList为1,3,4  已完成 平       minus=2
            var sub = minus(blackA,finishList);
            if( sub.length == 1 ){
                if( finishList[1]==sub[0] ){
                    return {flag:true,winner:blackA};
                }
                else{
                    return {flag:true,winner:[1,2,3,4]};
                }
            }
            else if( sub.length == 2 ){
                //三人中有两个非双A
                for(var i=0;i<2;i++){
                    if(finishList[0]==blackA[i]){
                        //如果第一名完成的是 双A  则平
                        return {flag:true,winner:[1,2,3,4]};
                    }
                }
                return {flag:true,winner:minus(blackA,[1,2,3,4])};
            }
        }
    }
    return {flag:false};
}
//hasOneFinished 判断某人是否完成
function hasOneFinished(id){
    for(var i = 0;i<finishList.length;i++){
        if(finishList[i]==id){
            return true;
        }
    }
    return false;
}